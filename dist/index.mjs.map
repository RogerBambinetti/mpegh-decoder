{"version":3,"sources":["../src/error/Errors.ts","../src/index.ts"],"sourcesContent":["export class PlatformNotSupported extends Error {\r\n    constructor() {\r\n        super('Platform not supported');\r\n    }\r\n}\r\n\r\nexport class InvalidInput extends Error {\r\n    constructor() {\r\n        super('Invalid input path');\r\n    }\r\n}\r\n\r\nexport class InvalidOutput extends Error {\r\n    constructor() {\r\n        super('Invalid output path');\r\n    }\r\n}","import path from 'node:path';\r\nimport { execFile } from 'node:child_process';\r\nimport { promisify } from 'node:util';\r\nimport callsites from 'callsites';\r\nimport { InvalidInput, InvalidOutput, PlatformNotSupported } from './error/Errors';\r\n\r\nconst execFilePromise = promisify(execFile);\r\n\r\ninterface IO {\r\n    input: string;\r\n    output?: string;\r\n}\r\n\r\ninterface Options {\r\n    cicp?: string;\r\n}\r\n\r\nconst paths: { [key: string]: string } = {\r\n    'win32': '../src/mpegh-decoder/mpeghDecoder.exe'\r\n};\r\n\r\nfunction validateIO(IO: IO) {\r\n    if (!paths[process.platform]) {\r\n        throw new PlatformNotSupported();\r\n    }\r\n\r\n    if (!path.extname(IO.input)) {\r\n        throw new InvalidInput();\r\n    }\r\n\r\n    IO.output = IO.output || IO.input.replace(path.extname(IO.input), '.wav');\r\n\r\n    if (!IO.output.endsWith('.wav')) {\r\n        throw new InvalidOutput();\r\n    }\r\n}\r\n\r\nconst mpeghDecoder = {\r\n    decode: async function (IO: IO, options?: Options) {\r\n        try {\r\n            validateIO(IO);\r\n\r\n            const args = ['-if', IO.input, '-of', IO.output as string];\r\n\r\n            if (options?.cicp) {\r\n                args.push('-tl');\r\n                args.push(options.cicp);\r\n            }\r\n\r\n            await execFilePromise(path.resolve(__dirname, paths[process.platform]), args);\r\n\r\n            const parentDirname = path.dirname(callsites()[0].getFileName() as string);\r\n\r\n            return path.resolve(parentDirname, IO.output as string);\r\n        } catch (error) {\r\n            throw error;\r\n        }\r\n    },\r\n    bulkDecode: async function (IO: IO[], options?: Options): Promise<string[]> {\r\n        const promises: Promise<string>[] = IO.map(io => mpeghDecoder.decode(io, options));\r\n        return await Promise.all(promises);\r\n    }\r\n};\r\n\r\nmodule.exports = mpeghDecoder;"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAa,sBAMA,cAMA;AAZb;AAAA;AAAA;AAAO,IAAM,uBAAN,cAAmC,MAAM;AAAA,MAC5C,cAAc;AACV,cAAM,wBAAwB;AAAA,MAClC;AAAA,IACJ;AAEO,IAAM,eAAN,cAA2B,MAAM;AAAA,MACpC,cAAc;AACV,cAAM,oBAAoB;AAAA,MAC9B;AAAA,IACJ;AAEO,IAAM,gBAAN,cAA4B,MAAM;AAAA,MACrC,cAAc;AACV,cAAM,qBAAqB;AAAA,MAC/B;AAAA,IACJ;AAAA;AAAA;;;AChBA,OAAO,UAAU;AACjB,SAAS,gBAAgB;AACzB,SAAS,iBAAiB;AAC1B,OAAO,eAAe;AAHtB;AAAA;AAIA;AAEA,QAAM,kBAAkB,UAAU,QAAQ;AAW1C,QAAM,QAAmC;AAAA,MACrC,SAAS;AAAA,IACb;AAEA,aAAS,WAAW,IAAQ;AACxB,UAAI,CAAC,MAAM,QAAQ,QAAQ,GAAG;AAC1B,cAAM,IAAI,qBAAqB;AAAA,MACnC;AAEA,UAAI,CAAC,KAAK,QAAQ,GAAG,KAAK,GAAG;AACzB,cAAM,IAAI,aAAa;AAAA,MAC3B;AAEA,SAAG,SAAS,GAAG,UAAU,GAAG,MAAM,QAAQ,KAAK,QAAQ,GAAG,KAAK,GAAG,MAAM;AAExE,UAAI,CAAC,GAAG,OAAO,SAAS,MAAM,GAAG;AAC7B,cAAM,IAAI,cAAc;AAAA,MAC5B;AAAA,IACJ;AAEA,QAAM,eAAe;AAAA,MACjB,QAAQ,SAAgB,IAAQ,SAAmB;AAAA;AAC/C,cAAI;AACA,uBAAW,EAAE;AAEb,kBAAM,OAAO,CAAC,OAAO,GAAG,OAAO,OAAO,GAAG,MAAgB;AAEzD,gBAAI,mCAAS,MAAM;AACf,mBAAK,KAAK,KAAK;AACf,mBAAK,KAAK,QAAQ,IAAI;AAAA,YAC1B;AAEA,kBAAM,gBAAgB,KAAK,QAAQ,WAAW,MAAM,QAAQ,QAAQ,CAAC,GAAG,IAAI;AAE5E,kBAAM,gBAAgB,KAAK,QAAQ,UAAU,EAAE,CAAC,EAAE,YAAY,CAAW;AAEzE,mBAAO,KAAK,QAAQ,eAAe,GAAG,MAAgB;AAAA,UAC1D,SAAS,OAAO;AACZ,kBAAM;AAAA,UACV;AAAA,QACJ;AAAA;AAAA,MACA,YAAY,SAAgB,IAAU,SAAsC;AAAA;AACxE,gBAAM,WAA8B,GAAG,IAAI,QAAM,aAAa,OAAO,IAAI,OAAO,CAAC;AACjF,iBAAO,MAAM,QAAQ,IAAI,QAAQ;AAAA,QACrC;AAAA;AAAA,IACJ;AAEA,WAAO,UAAU;AAAA;AAAA;","names":[]}